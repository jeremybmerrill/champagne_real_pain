<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jeremy B. Merrill">
<meta name="dcterms.date" content="2023-09-25">

<title>Champagne for my real friends</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-0K33PQMW1P"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-0K33PQMW1P', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<meta property="og:title" content="Real tricks for my meh friends, a real croc for my faux friends">
<meta property="og:description" content="‘Champagne for my real friends, real pain for my sham friends’ is clever. Let’s find more phrases like that with NLP.">
<meta property="og:image" content="https://jeremybmerrill.com/images/folkrock_croc.png">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Champagne for my real friends</h1>
            <p class="subtitle lead">Real pain for my sham friends, real tricks for my meh friends, and finding more like this with NLP</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p><a href="https://www.jeremybmerrill.com">Jeremy B. Merrill</a> </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 25, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#but-how-do-computers-know-how-words-sound" id="toc-but-how-do-computers-know-how-words-sound" class="nav-link active" data-scroll-target="#but-how-do-computers-know-how-words-sound">But how do computers know how words sound?</a></li>
  <li><a href="#an-initial-rubric-for-a-champagne-phrase" id="toc-an-initial-rubric-for-a-champagne-phrase" class="nav-link" data-scroll-target="#an-initial-rubric-for-a-champagne-phrase">An initial rubric for a <code>champagne phrase</code></a></li>
  <li><a href="#implementing-our-initial-rubric" id="toc-implementing-our-initial-rubric" class="nav-link" data-scroll-target="#implementing-our-initial-rubric">Implementing our initial rubric</a>
  <ul class="collapse">
  <li><a href="#cleaning-up-the-pronunciations" id="toc-cleaning-up-the-pronunciations" class="nav-link" data-scroll-target="#cleaning-up-the-pronunciations">Cleaning up the pronunciations</a></li>
  <li><a href="#finding-pain-words" id="toc-finding-pain-words" class="nav-link" data-scroll-target="#finding-pain-words">Finding pain words</a></li>
  </ul></li>
  <li><a href="#a-more-robust-rubric-for-champagne-phrases" id="toc-a-more-robust-rubric-for-champagne-phrases" class="nav-link" data-scroll-target="#a-more-robust-rubric-for-champagne-phrases">A more robust rubric for <code>champagne phrases</code></a>
  <ul class="collapse">
  <li><a href="#pain-words-and-champagne-compound-words-have-to-be-nouns" id="toc-pain-words-and-champagne-compound-words-have-to-be-nouns" class="nav-link" data-scroll-target="#pain-words-and-champagne-compound-words-have-to-be-nouns">Pain words and champagne compound words have to be nouns</a></li>
  <li><a href="#ignore-very-rare-words" id="toc-ignore-very-rare-words" class="nav-link" data-scroll-target="#ignore-very-rare-words">Ignore very rare words</a></li>
  <li><a href="#more-permissive-vowel-matching" id="toc-more-permissive-vowel-matching" class="nav-link" data-scroll-target="#more-permissive-vowel-matching">More permissive vowel matching</a></li>
  <li><a href="#champagne-compound-words-are-positive-pain-words-are-negative" id="toc-champagne-compound-words-are-positive-pain-words-are-negative" class="nav-link" data-scroll-target="#champagne-compound-words-are-positive-pain-words-are-negative">Champagne compound words are positive, pain words are negative</a></li>
  </ul></li>
  <li><a href="#implementing-our-final-rubric-for-champagne-phrases" id="toc-implementing-our-final-rubric-for-champagne-phrases" class="nav-link" data-scroll-target="#implementing-our-final-rubric-for-champagne-phrases">Implementing our final rubric for <code>champagne phrases</code></a></li>
  <li><a href="#for-my-faux-sham-mid-meh-and-bad-friends" id="toc-for-my-faux-sham-mid-meh-and-bad-friends" class="nav-link" data-scroll-target="#for-my-faux-sham-mid-meh-and-bad-friends">____ for my faux, sham, mid, meh and bad friends</a></li>
  <li><a href="#a-worked-example" id="toc-a-worked-example" class="nav-link" data-scroll-target="#a-worked-example">A worked example</a></li>
  <li><a href="#future-enhancements" id="toc-future-enhancements" class="nav-link" data-scroll-target="#future-enhancements">Future enhancements</a>
  <ul class="collapse">
  <li><a href="#use-a-for-pain-words-that-are-count-nouns" id="toc-use-a-for-pain-words-that-are-count-nouns" class="nav-link" data-scroll-target="#use-a-for-pain-words-that-are-count-nouns">Use “a” for pain words that are count nouns</a></li>
  <li><a href="#metrics-for-my-real-friends" id="toc-metrics-for-my-real-friends" class="nav-link" data-scroll-target="#metrics-for-my-real-friends">Metrics for my real friends</a></li>
  <li><a href="#better-phonology" id="toc-better-phonology" class="nav-link" data-scroll-target="#better-phonology">Better phonology</a></li>
  <li><a href="#exclude-true-compound-words" id="toc-exclude-true-compound-words" class="nav-link" data-scroll-target="#exclude-true-compound-words">Exclude true compound words</a></li>
  <li><a href="#improve-positivenegative-classification" id="toc-improve-positivenegative-classification" class="nav-link" data-scroll-target="#improve-positivenegative-classification">Improve positive/negative classification</a></li>
  <li><a href="#what-pain-words-are-excluded-by-the-existing-positivenegative-methodology" id="toc-what-pain-words-are-excluded-by-the-existing-positivenegative-methodology" class="nav-link" data-scroll-target="#what-pain-words-are-excluded-by-the-existing-positivenegative-methodology">What pain words are excluded by the existing positive/negative methodology?</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>What a catchy phrase. Someone <a href="https://xkcd.com/356/">nerd-sniped me</a> in July, essentially daring me to find some more. Here’s how I tricked the computer into coming up with more <code>champagne phrases</code> like this, using natural language processing tools like</p>
<ul>
<li>the CMU Pronouncing Dictionary</li>
<li>GLoVe</li>
<li>a wordlist with frequencies</li>
<li>WordNet</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click for a sample of the final output (spoiler alert!)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li>metrics for my real friends, real tricks for my meh friends</li>
<li>focus for my real friends, real cuss for my faux friends</li>
<li>shamrocks for my real friends, real rocks for my sham friends</li>
<li>folkrock for my real friends, real croc for my faux friends</li>
<li>photos for my real friends, real toes for my faux friends</li>
<li>midrash for my real friends, real rash for my mid friends</li>
<li>medics for my real friends, real dicks for my meh friends</li>
<li>crappie for my real friends, real pee for my crap friends</li>
</ul>
</div>
</div>
</div>
<section id="but-how-do-computers-know-how-words-sound" class="level2">
<h2 class="anchored" data-anchor-id="but-how-do-computers-know-how-words-sound">But how do computers know how words sound?</h2>
<p>The <a href="www.speech.cs.cmu.edu/cgi-bin/cmudict">CMU Pronouncing Dictionary</a> is a classical natural language processing resource that lists words and their pronunciations. It’s thirty years old! It was compiled by humans who painstakingly listed each word’s pronunciations – no neural nets or artificial intelligence here.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What is classical NLP? Why not use ChatGPT?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>So-called classical natural language processing relies on computational representations of the kinds of grammar concepts used by linguists. Think back to middle-school English class. You learned about nouns and verbs and how to diagram a sentence. Natural language processing analyzes language with those kinds of representations.</p>
<p>This differs from AI-based NLP, whose representation of language tends to be more of black box. That black box representation is good for a lot of things, but it’s famously terrible at computational humor.</p>
<p>Here’s what ChatGPT gave me when I asked it for <em>can you come up with some variants on the “champagne for my real friends, real pain for my sham friends?” template, but using different words than champagne, sham and pain?</em>.</p>
<ol type="1">
<li>“Laughter for my true friends, heartfelt tears for my false friends.”</li>
<li>“Confetti for my loyal friends, bitter truth for my deceitful friends.”</li>
<li>“Hugs for my genuine friends, icy distance for my deceptive friends.”</li>
<li>“Sunshine for my authentic friends, thunderstorms for my treacherous friends.”</li>
</ol>
<p>Those are terrible! They don’t follow the template at all! We can do better with classical NLP.</p>
<p>(But if you can coax better examples out of ChatGPT, let me know!)</p>
</div>
</div>
</div>
<p>If we’re gonna find more slogans like <em>champagne for my real friends, real pain for my sham friends</em>, we’ll have to find words like <em>champagne</em> that <strong>sound</strong> like compounds of a word like <em>sham</em> and a word like <em>pain</em> – regardless of how they’re spelled.</p>
<p>Another example of what we’re looking for is <em>focus for my real friends, real cuss for my faux friends</em>. In this example, <em>focus</em> is our <code>champagne compound word</code>, and it’s composed of <em>faux</em> (a <code>sham word</code>) and <em>cuss</em> (a <code>pain word</code>).</p>
<p>Look below to see what the pronunciation of <em>champagne</em> looks like, and how it’s made up of the pronunciations of <em>sham</em> and <em>pain</em>.</p>
<p>(Throughout this post, sections of computer code are collapsed. If you want to see the Python code that makes this project work, click the little gray arrow on the left to expand the code.)</p>
<div class="cell" data-execution_count="1">
<details>
<summary>print a few pronunciations</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cmudict</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>cmudict_dict <span class="op">=</span> cmudict.<span class="bu">dict</span>()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word <span class="kw">in</span> [<span class="st">"champagne"</span>, <span class="st">"sham"</span>, <span class="st">"pain"</span>]:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"pronunciation of </span><span class="sc">{}</span><span class="st"> is </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(word, cmudict_dict[word]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>pronunciation of champagne is [['SH', 'AE0', 'M', 'P', 'EY1', 'N']]
pronunciation of sham is [['SH', 'AE1', 'M']]
pronunciation of pain is [['P', 'EY1', 'N']]</code></pre>
</div>
</div>
</section>
<section id="an-initial-rubric-for-a-champagne-phrase" class="level2">
<h2 class="anchored" data-anchor-id="an-initial-rubric-for-a-champagne-phrase">An initial rubric for a <code>champagne phrase</code></h2>
<p>A <code>champagne phrase</code> is (preliminarily) defined as <strong><code>champagne compound word</code> for my real friends, real <code>pain word</code> for my <code>sham word</code> friends</strong>, where<code>sham word</code> is an adjective and a <code>pain word</code> is a word that, when their pronunciations are combined, make a <code>champagne compound word</code>.</p>
<p>We’ll revise this later, but this is enough to try to get started with generating <code>champagne phrases.</code></p>
</section>
<section id="implementing-our-initial-rubric" class="level2">
<h2 class="anchored" data-anchor-id="implementing-our-initial-rubric">Implementing our initial rubric</h2>
<p>Let’s use “faux” as our <code>sham word</code>. So we’re looking for phrases like <em>faux pain for my real friends, real pain for my faux friends</em>… except where <em>faux pain</em> is a real word.</p>
<p>So, now, let’s find our <code>champagne compound word</code>s, but starting with the sound “faux”.</p>
<section id="cleaning-up-the-pronunciations" class="level3">
<h3 class="anchored" data-anchor-id="cleaning-up-the-pronunciations">Cleaning up the pronunciations</h3>
<p>The pronunciations in our example above <em>almost</em> match, but not quite.</p>
<pre><code>champagne: [['SH', 'AE0', 'M', 'P', 'EY1', 'N']]
sham:      [['SH', 'AE1', 'M']]
pain:                        [['P', 'EY1', 'N']]</code></pre>
<p>The problem is that the vowel in <em>sham</em> (<code>AE1</code>) isn’t quite the same as the first vowel in <em>champagne</em> (<code>AE0</code>). The numbers represent stress. <code>1</code> is primary stress; <code>2</code> is secondary, and <code>0</code> is no stress. We don’t really care about stress for our joke format, so we will “clean” the data to ignore stress.</p>
<div class="cell" data-execution_count="3">
<details>
<summary>def remove_stress(phon):</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove_stress(phon):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(i <span class="cf">for</span> i <span class="kw">in</span> phon <span class="cf">if</span> <span class="kw">not</span> i.isdigit())</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clean_phonemes(pron):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    pron <span class="op">=</span> <span class="bu">tuple</span>(remove_stress(phon) <span class="cf">for</span> phon <span class="kw">in</span> pron) <span class="co"># remove stress        </span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pron</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># map nouns to their "cleaned" pronunciations</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>word_pronunciations <span class="op">=</span> {}</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word, prons <span class="kw">in</span> cmudict_dict.items():</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    word_pronunciations[word] <span class="op">=</span> [clean_phonemes(pron) <span class="cf">for</span> pron <span class="kw">in</span> prons]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="4">
<details>
<summary>def find_candidate_champagne_compound_words(word_prons):</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Due to an error in the CMU pronouncing dictionary, we have to specify that _faux_ </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># is actually pronounced like _foe_. (Not like _fox_.)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>SHAM_WORD_OVERRIDE <span class="op">=</span> <span class="st">"foe"</span> <span class="co"># None or "foe" # in case the pronunciation of the TARGET_WORD is wrong, as it oddly is for "faux"</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>SHAM_SYLLABLE <span class="op">=</span> word_pronunciations[SHAM_WORD_OVERRIDE <span class="kw">or</span> SHAM_WORD][<span class="dv">0</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>HOW_MANY_TO_SHOW <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_candidate_champagne_compound_words(word_prons, sham_syllable<span class="op">=</span>SHAM_SYLLABLE):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">    champagne compound words have to start with the same sounds as the cham word (but can't be identical, it has to be longer!)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    word, prons <span class="op">=</span> word_prons <span class="co"># destructuring</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">any</span>([                                              <span class="co"># candidate words must:</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>               pron[:<span class="bu">len</span>(sham_syllable)] <span class="op">==</span> sham_syllable <span class="kw">and</span> <span class="co"># start with same sounds</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>               pron <span class="op">!=</span> sham_syllable                          <span class="co"># but be different</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pron <span class="kw">in</span> prons])</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>nouns_starting_with_sham_word <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(find_candidate_champagne_compound_words, word_pronunciations.items()))</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Here are words (our candidate champagne compound words) that start with </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(SHAM_SYLLABLE))</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> noun, prons <span class="kw">in</span> nouns_starting_with_sham_word[:HOW_MANY_TO_SHOW]:</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>noun<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>prons<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(nouns_starting_with_sham_word) <span class="op">&gt;</span> HOW_MANY_TO_SHOW:</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"and </span><span class="sc">{}</span><span class="st"> additional words hidden"</span>.<span class="bu">format</span>(<span class="bu">len</span>(nouns_starting_with_sham_word) <span class="op">-</span> HOW_MANY_TO_SHOW))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Here are words (our candidate champagne compound words) that start with ('F', 'OW')
 - faucette: [('F', 'OW', 'S', 'EH', 'T')]
 - faucheux: [('F', 'OW', 'SH', 'OW')]
 - faupel: [('F', 'OW', 'P', 'EH', 'L')]
 - fauteux: [('F', 'OW', 'T', 'OW')]
 - foal: [('F', 'OW', 'L')]
 - foale: [('F', 'OW', 'L')]
 - foale's: [('F', 'OW', 'L', 'Z')]
 - foaling: [('F', 'OW', 'L', 'IH', 'NG')]
 - foam: [('F', 'OW', 'M')]
 - foaming: [('F', 'OW', 'M', 'IH', 'NG')]
 - foams: [('F', 'OW', 'M', 'Z')]
 - foamy: [('F', 'OW', 'M', 'IY')]
 - fobel: [('F', 'OW', 'B', 'AH', 'L')]
 - fobel's: [('F', 'OW', 'B', 'AH', 'L', 'Z')]
 - fobes: [('F', 'OW', 'B', 'Z')]
and 154 additional words hidden</code></pre>
</div>
</div>
</section>
<section id="finding-pain-words" class="level3">
<h3 class="anchored" data-anchor-id="finding-pain-words">Finding pain words</h3>
<p>For each of our candidate <code>champagne compound word</code>s (<em>folklore</em>, <em>folder</em>, etc.), we’re going to check and see if it contains a <code>pain word</code>. That is, we’re asking if <em>klore</em> or <em>lder</em> are words – even if they’re spelled differently.</p>
<p>We do this really naively, by looping through every pronunciation of every single word in the dictionary, to see if matches the second half of the pronunciation of our candidate <code>champagne compound word</code>.</p>
<div class="cell" data-execution_count="5">
<details>
<summary>{} for my real friends, real {} for my {} friends</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>count_so_far <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>HOW_MANY_TO_SHOW <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> candidate_word, candidate_prons <span class="kw">in</span> nouns_starting_with_sham_word:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pron <span class="kw">in</span> candidate_prons:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> word, prons <span class="kw">in</span> word_pronunciations.items():</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (pron[<span class="bu">len</span>(SHAM_SYLLABLE):] <span class="kw">in</span> prons) <span class="kw">or</span> (pron[<span class="bu">len</span>(SHAM_SYLLABLE)<span class="op">-</span><span class="dv">1</span>:] <span class="kw">in</span> prons):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                count_so_far <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> count_so_far <span class="op">&lt;=</span> HOW_MANY_TO_SHOW: </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">"</span><span class="sc">{}</span><span class="st"> for my real friends, real </span><span class="sc">{}</span><span class="st"> for my </span><span class="sc">{}</span><span class="st"> friends"</span>.<span class="bu">format</span>(candidate_word, word, SHAM_WORD))</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> count_so_far <span class="op">&gt;</span> HOW_MANY_TO_SHOW:</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"... (</span><span class="sc">{</span>count_so_far <span class="op">-</span> HOW_MANY_TO_SHOW<span class="sc">}</span><span class="ss"> additional examples hidden)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>faucette for my real friends, real set for my faux friends
faucette for my real friends, real sette for my faux friends
faucheux for my real friends, real chau for my faux friends
faucheux for my real friends, real schau for my faux friends
faucheux for my real friends, real show for my faux friends
faupel for my real friends, real pehl for my faux friends
faupel for my real friends, real pell for my faux friends
faupel for my real friends, real pelle for my faux friends
fauteux for my real friends, real toe for my faux friends
fauteux for my real friends, real tow for my faux friends
fauteux for my real friends, real towe for my faux friends
foal for my real friends, real ohl for my faux friends
foal for my real friends, real ol' for my faux friends
foal for my real friends, real ole for my faux friends
foale for my real friends, real ohl for my faux friends
... (224 additional examples hidden)</code></pre>
</div>
</div>
<p>Very cool! Those are kind of right.</p>
<p><em>focusing for my real friends, real kissing for my faux friends</em> has got a ring to it, but kind of has the wrong valence. Who wishes kisses on their faux friends? Our <code>pain word</code> should be negative; and the <code>champagne compound word</code> should be positive, or at least neutral.</p>
<p>But let’s look closer.</p>
<ul>
<li><em>foamy for my real friends, real me for my faux friends</em></li>
</ul>
<p>This is kind of funny, but <em>foamy</em> is an adjective. That means that the phrase doesn’t make a lot of sense. Let’s try to skip those.</p>
<ul>
<li><em>focus for my real friends, real cos for my faux friends</em></li>
<li><em>focus for my real friends, real kiss for my faux friends</em></li>
<li><em>focus for my real friends, real kos for my faux friends</em></li>
</ul>
<p>Some of the proposals are doubled. And, <em>cos</em> and <em>kos</em> aren’t words I’ve heard of, we should try to eliminate those.</p>
</section>
</section>
<section id="a-more-robust-rubric-for-champagne-phrases" class="level2">
<h2 class="anchored" data-anchor-id="a-more-robust-rubric-for-champagne-phrases">A more robust rubric for <code>champagne phrases</code></h2>
<p>In our first attempt at generating these phrases, we noticed a few problems that add up to too many proposed champagne phrases that are too often crappy.</p>
<ul>
<li>non-nouns</li>
<li>weird, very rare words</li>
<li>multiple pronunciations of the same sounds</li>
<li>overprecise vowel matches mean we miss some slant rhymes that should be ok.</li>
<li>some of the <code>pain words</code> are actually positive; it doesn’t make sense to wish a real kiss for your faux friends.</li>
</ul>
<p>Our initial rubric was:</p>
<blockquote class="blockquote">
<p>A <code>champagne phrase</code> is (preliminarily) defined as <strong><code>champagne compound word</code> for my real friends, real <code>pain word</code> for my <code>sham word</code> friends</strong>, where<code>sham word</code> is an adjective and a <code>pain word</code> is a word that, when their pronunciations are combined, make a <code>champagne compound word</code>.</p>
</blockquote>
<p>We can revise that for a final rubric:</p>
<blockquote class="blockquote">
<p>A <code>champagne phrase</code> is defined as <strong><code>champagne compound word</code> for my real friends, real <code>pain word</code> for my <code>sham word</code> friends</strong>, where a <code>sham word</code> is an adjective and a <code>pain word</code> is a frequent, common noun with a negative meaning that, when their pronunciations are combined (with perhaps a bit of phonological fudging), make a <code>champagne compound word</code> with positive or neutral meaning.</p>
</blockquote>
<p>We’ll only count one champagne phrase per pronunciation of a <code>champagne compound word</code>.</p>
<p>Here’s our implementation.</p>
<section id="pain-words-and-champagne-compound-words-have-to-be-nouns" class="level3">
<h3 class="anchored" data-anchor-id="pain-words-and-champagne-compound-words-have-to-be-nouns">Pain words and champagne compound words have to be nouns</h3>
<p>Let’s use Wordnet to filter just to words that are common nouns – excluding adjectives and proper nouns. More specifically, for our purposes, a common noun is a word that has a lemma in WordNet that’s classified as a noun and is lower-cased.</p>
<p>Wordnet doesn’t include every word, which means we would inadvertantly exclude gems like these,</p>
<ul>
<li><em>folkrock for my real friends, real croc for my faux friends</em></li>
<li><em>chamonix for real friends, real money for my sham friends</em></li>
<li><em>midrash for my real friends, real rash for my mid friends</em></li>
<li><em>shampoo for my real friends, real poo for my sham friends</em></li>
</ul>
<p>because <em>folkrock</em>, <em>chamonix</em>, <em>poo</em>, and <em>midrash</em> aren’t in Wordnet. (The first three are in the CMU Pronouncing Dictionary.) So we add them back here as special extra nouns.</p>
<p>(And we definitely do want <em>folkrock for my real friends, real croc for my faux friends</em>, because it lets us show this wonderful, low-effort piece of AI-art of a vengeful Americana banjo player.) <img src="https://jeremybmerrill.com/images/folkrock_croc.png" class="preview-image img-fluid" style="width:50.0%"></p>
<div class="cell" data-execution_count="8">
<details>
<summary>def is_noun(word):</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nltk.stem <span class="im">import</span> WordNetLemmatizer</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>wnl <span class="op">=</span> WordNetLemmatizer()</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_common_noun(word):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">    A word is a common noun (versus a proper noun) if its lemma is lowercase</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">    or the word itself is present as a lemma in wordnet.</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">    A lemma is a root word with any morphology removed, like `squirrel` is the lemma for "squirrels".</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">    For unknown reasons (perhaps a bug), the NLTK implementation of Wordnet's tokenizer returns a lemma</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">    of "Te" for "tess" (referring to the element Tellurium), or "Ca" (an abbreviation for California).</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Another noun's lemma (as generated by NLTK's WordNetLemmatizer) isn't contained in Wordnet, but the</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">    raw form of the word itself is. (I don't remember which word). That's why we include `word in wordnet_lemmas`.</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    input_lemma <span class="op">=</span> wnl.lemmatize(word, pos<span class="op">=</span><span class="st">'n'</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    wordnet_lemmas <span class="op">=</span> [lemma.name() <span class="cf">for</span> lemma <span class="kw">in</span> wordnet.synsets(word, pos<span class="op">=</span>wordnet.NOUN)[<span class="dv">0</span>].lemmas()]</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> input_lemma <span class="kw">in</span> wordnet_lemmas <span class="kw">or</span> word <span class="kw">in</span> wordnet_lemmas</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_common_noun(<span class="st">"mecca"</span>)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_common_noun(<span class="st">"dawson"</span>)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_common_noun(<span class="st">"ca"</span>)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_common_noun(<span class="st">"dc"</span>)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_common_noun(<span class="st">"tess"</span>)</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_common_noun(<span class="st">"toes"</span>)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_common_noun(<span class="st">"champagne"</span>)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_common_noun(<span class="st">"medics"</span>)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_noun(word):</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="co">    A word is a noun if it is present in wordnet as a noun AND it is a common noun.</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">any</span>(synset <span class="cf">for</span> synset <span class="kw">in</span> wordnet.synsets(word, pos<span class="op">=</span>wordnet.NOUN) <span class="cf">if</span> is_common_noun(word)) <span class="kw">or</span> word <span class="kw">in</span> EXTRA_NOUNS</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_noun(<span class="st">'mite'</span>)      <span class="co"># testing basic case</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_noun(<span class="st">'might'</span>)     <span class="co"># testing words that can be multiple PoS</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_noun(<span class="st">'shamrocks'</span>) <span class="co"># testing plurals</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_noun(<span class="st">'mites'</span>)     <span class="co"># testing plurals</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_noun(<span class="st">'poo'</span>)       <span class="co"># testing manual additions</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_noun(<span class="st">'photographed'</span>)     <span class="co"># testing handling of inflected verbs</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_noun(<span class="st">'focused'</span>)          <span class="co"># testing handling of inflected verbs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="ignore-very-rare-words" class="level3">
<h3 class="anchored" data-anchor-id="ignore-very-rare-words">Ignore very rare words</h3>
<p>First, we download a list of word frequencies; we’ll ignore anything that occurs less than 500,000 times in the corpus. Then, we download a list of nouns; we’ll ignore anything that isn’t a noun. (We also add back a few nouns I like.)</p>
<div class="cell" data-execution_count="9">
<details>
<summary>download file of the 1/3 million most frequent words, with counts</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ignore words that occur less than this many times in the Google Web Trillion Word Corpus </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># many of these less-frequent words are very bizarre, but appear in the CMU Pronouncing Dictionary nevertheless.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># the champagne and sham words can be rare, but they must be nouns.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># the pain word must be a more common noun.</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"># download file of "The 1/3 million most frequent words, all lowercase, with counts"</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>wget <span class="op">-</span>nc <span class="op">--</span>quiet https:<span class="op">//</span>norvig.com<span class="op">/</span>ngrams<span class="op">/</span>count_1w.txt</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> csv</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"count_1w.txt"</span>) <span class="im">as</span> f:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    word_frequencies <span class="op">=</span> <span class="bu">dict</span>([(row[<span class="dv">0</span>], <span class="bu">int</span>(row[<span class="dv">1</span>])) <span class="cf">for</span> row <span class="kw">in</span> csv.reader(f, delimiter<span class="op">=</span><span class="st">"</span><span class="ch">\t</span><span class="st">"</span>)])</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>MIN_FREQUENCY <span class="op">=</span> <span class="dv">100_000</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="more-permissive-vowel-matching" class="level3">
<h3 class="anchored" data-anchor-id="more-permissive-vowel-matching">More permissive vowel matching</h3>
<p>We also don’t care about all the vowel distinctions that the dictionary uses. We’ll implement “vowel reductions” that mirror some of the ways American English speakers can change vowels in fast or casual speech, so that near-identical words are okay.</p>
<p>Also we ignore very uncommon words and non-nouns, which don’t fit in the joke format.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What are these vowels?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="cell" data-execution_count="10">
<details>
<summary>finding examples of each vowel, so we can find which vowels to combine</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    has_pandas <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span>:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    has_pandas <span class="op">=</span> <span class="va">False</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>vowels <span class="op">=</span> [ph <span class="cf">for</span> ph, types <span class="kw">in</span> cmudict.phones() <span class="cf">if</span> types[<span class="dv">0</span>] <span class="op">==</span> <span class="st">'vowel'</span>]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>vowel_examples <span class="op">=</span> []</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> vowel <span class="kw">in</span> vowels:</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> word, prons <span class="kw">in</span> <span class="bu">sorted</span>(cmudict_dict.items(), key<span class="op">=</span><span class="kw">lambda</span> word_prons: <span class="op">-</span>word_frequencies.get(word_prons[<span class="dv">0</span>], <span class="dv">0</span>)):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">"'"</span> <span class="kw">in</span> word <span class="kw">or</span> <span class="st">'.'</span> <span class="kw">in</span> word: <span class="cf">continue</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_noun(word): <span class="cf">continue</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'R'</span> <span class="kw">in</span> prons[<span class="dv">0</span>]: <span class="cf">continue</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(word) <span class="op">&lt;</span> <span class="dv">3</span> <span class="kw">or</span> <span class="bu">len</span>(word) <span class="op">&gt;=</span> <span class="dv">6</span>: <span class="cf">continue</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> vowel <span class="kw">in</span> clean_phonemes(prons[<span class="dv">0</span>]):</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            vowel_examples.append((vowel, word, prons[<span class="dv">0</span>]))</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> has_pandas:</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    display(pd.DataFrame(vowel_examples, columns<span class="op">=</span>[<span class="st">"vowel"</span>, <span class="st">"example"</span>, <span class="st">"pronunciation"</span>]).set_index(<span class="st">'vowel'</span>))</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vowel, example, pron <span class="kw">in</span> vowel_examples:</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(vowel, example, pronunciation)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">example</th>
<th data-quarto-table-cell-role="th">pronunciation</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">vowel</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">AA</td>
<td>top</td>
<td>[T, AA1, P]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">AE</td>
<td>have</td>
<td>[HH, AE1, V]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">AH</td>
<td>one</td>
<td>[W, AH1, N]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">AO</td>
<td>law</td>
<td>[L, AO1]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">AW</td>
<td>out</td>
<td>[AW1, T]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">AY</td>
<td>time</td>
<td>[T, AY1, M]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">EH</td>
<td>web</td>
<td>[W, EH1, B]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">ER</td>
<td>first</td>
<td>[F, ER1, S, T]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">EY</td>
<td>page</td>
<td>[P, EY1, JH]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">IH</td>
<td>will</td>
<td>[W, IH1, L]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">IY</td>
<td>see</td>
<td>[S, IY1]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">OW</td>
<td>home</td>
<td>[HH, OW1, M]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">OY</td>
<td>point</td>
<td>[P, OY1, N, T]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">UH</td>
<td>good</td>
<td>[G, UH1, D]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">UW</td>
<td>news</td>
<td>[N, UW1, Z]</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell" data-execution_count="11">
<details>
<summary>def reduce_phonemes(pron):</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>VOWEL_REDUCTIONS <span class="op">=</span> {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"AH"</span>: <span class="st">"AH"</span>, <span class="st">"AA"</span>: <span class="st">"AH"</span>, <span class="st">"AO"</span>: <span class="st">"AH"</span>, <span class="st">"UH"</span>: <span class="st">"AH"</span>, <span class="st">"IH"</span>: <span class="st">"AH"</span>, <span class="st">"EH"</span>: <span class="st">"AH"</span>, </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"OW"</span>: <span class="st">"AH"</span> <span class="co"># special for chamonix / money</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>VOWEL_STRICTNESS <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 1 = least; compare only first char of vowel symbol </span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 2 = medium; perform some vowel reductions</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 3 = most; compare vowels as is (with stress removed)</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_vowel(phon):</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> phones_dict[remove_stress(phon)][<span class="dv">0</span>] <span class="op">==</span> <span class="st">'vowel'</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>phones_dict <span class="op">=</span> <span class="bu">dict</span>(cmudict.phones())</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reduce_phonemes(pron, vowel_strictness<span class="op">=</span>VOWEL_STRICTNESS):</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> vowel_strictness <span class="op">&lt;</span> <span class="dv">3</span>:</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        pron <span class="op">=</span> [(phon[<span class="dv">0</span>] <span class="cf">if</span> (vowel_strictness <span class="op">==</span> <span class="dv">1</span>) <span class="cf">else</span> VOWEL_REDUCTIONS.get(remove_stress(phon), phon)) <span class="cf">if</span> is_vowel(phon) <span class="cf">else</span> phon <span class="cf">for</span> phon <span class="kw">in</span> pron]</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    pron <span class="op">=</span> clean_phonemes(pron) <span class="co"># remove stress        </span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pron</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="co"># `assert` lines are tests to make sure I didn't F it up.</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"pronunciation of 'ruck', as is    </span><span class="sc">{}</span><span class="st">"</span>  .<span class="bu">format</span>(          <span class="bu">tuple</span>(cmudict_dict[<span class="st">"ruck"</span>][<span class="dv">0</span>])))</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"pronunciation of 'ruck', cleaned  </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>( reduce_phonemes(cmudict_dict[<span class="st">"ruck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">2</span>)))</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> reduce_phonemes(cmudict.<span class="bu">dict</span>()[<span class="st">"ruck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">2</span>)[<span class="dv">1</span>] <span class="op">==</span> <span class="st">"AH"</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"pronunciation of 'wreck', as is   </span><span class="sc">{}</span><span class="st">"</span>  .<span class="bu">format</span>(          <span class="bu">tuple</span>(cmudict_dict[<span class="st">"wreck"</span>][<span class="dv">0</span>])))</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"pronunciation of 'wreck', cleaned </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>( reduce_phonemes(cmudict_dict[<span class="st">"wreck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">2</span>)))</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> reduce_phonemes(cmudict.<span class="bu">dict</span>()[<span class="st">"wreck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">2</span>)[<span class="dv">1</span>] <span class="op">==</span> <span class="st">"AH"</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> reduce_phonemes(cmudict.<span class="bu">dict</span>()[<span class="st">"ruck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">1</span>)[<span class="dv">1</span>] <span class="op">==</span> <span class="st">"A"</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> reduce_phonemes(cmudict.<span class="bu">dict</span>()[<span class="st">"wreck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">1</span>)[<span class="dv">1</span>] <span class="op">==</span> <span class="st">"E"</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> reduce_phonemes(cmudict.<span class="bu">dict</span>()[<span class="st">"ruck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">3</span>)[<span class="dv">1</span>] <span class="op">==</span> <span class="st">"AH"</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> reduce_phonemes(cmudict.<span class="bu">dict</span>()[<span class="st">"wreck"</span>][<span class="dv">0</span>], vowel_strictness<span class="op">=</span><span class="dv">3</span>)[<span class="dv">1</span>] <span class="op">==</span> <span class="st">"EH"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>pronunciation of 'ruck', as is    ('R', 'AH1', 'K')
pronunciation of 'ruck', cleaned  ('R', 'AH', 'K')
pronunciation of 'wreck', as is   ('R', 'EH1', 'K')
pronunciation of 'wreck', cleaned ('R', 'AH', 'K')</code></pre>
</div>
</div>
</section>
<section id="champagne-compound-words-are-positive-pain-words-are-negative" class="level3">
<h3 class="anchored" data-anchor-id="champagne-compound-words-are-positive-pain-words-are-negative">Champagne compound words are positive, pain words are negative</h3>
<p><em>fomite for my real friends, real might for my faux friends</em> doesn’t really make sense. You want to wish something bad on your faux friends, not something good, like might! And fomites are infection-carrying particles – which we don’t really want to wish on our real friends! So we want to filter our candidate words to ensure that the <code>champagne compound words</code> are positive and <code>pain words</code> are negative.</p>
<p>But the concept of negativity that we’re trying to capture here is really complex.</p>
<p>This attempt uses GLoVe embeddings. For <code>pain words</code>, it accepts only words that are closer to the average embedding of some negative words (like <em>bad</em>, <em>painful</em>) and some handpicked <code>pain words</code> I particularly like (like <code>tricks</code> and <code>cuss</code>) than to the average embedding of some positive words and some handpicked <code>champagne compound words</code>. (Champagne compound words are filtered to be the opposite.)</p>
<p>It also doesn’t work perfectly.</p>
<div class="cell" data-execution_count="13">
<details>
<summary>classifying with handpicked positive and negative words</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gensim.downloader <span class="im">as</span> gensim_downloader</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'glove_model'</span> <span class="kw">not</span> <span class="kw">in</span> <span class="bu">locals</span>():</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    glove_model <span class="op">=</span> gensim_downloader.load(<span class="st">"glove-wiki-gigaword-200"</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># handpicked positive words and champagne compound words that I like, plus some attempted corrections</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>HANDPICKED_POSITIVE_WORDS <span class="op">=</span> [<span class="st">"positive"</span>, <span class="st">"positivity"</span>, <span class="st">"good"</span>, <span class="st">"healthy"</span>, <span class="st">"safe"</span>, <span class="st">"normal"</span>, <span class="st">"beautiful"</span>, <span class="st">"pea"</span>, <span class="st">"tagine"</span>, <span class="st">"fondue"</span>]</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>HANDPICKED_CHAMPAGNE_COMPOUND_WORDS <span class="op">=</span> [<span class="st">"champagne"</span>, <span class="st">"metrics"</span>, <span class="st">"focus"</span>, <span class="st">"shamrocks"</span>, <span class="st">"photos"</span>, <span class="st">"medics"</span>]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>POSITIVE_WORDS <span class="op">=</span> HANDPICKED_POSITIVE_WORDS <span class="op">+</span> HANDPICKED_CHAMPAGNE_COMPOUND_WORDS <span class="op">+</span> [<span class="st">"kisses"</span>, <span class="st">"jewish"</span>, <span class="st">"midrash"</span>]</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co"># handpicked negative words and pain words that I like</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>HANDPICKED_NEGATIVE_WORDS <span class="op">=</span> [<span class="st">"bad"</span>, <span class="st">"badness"</span>, <span class="st">"evil"</span>, <span class="st">"painful"</span>, <span class="st">"dangerous"</span>, <span class="st">"negative"</span>, <span class="st">"weird"</span>, <span class="st">"ugly"</span>]</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>HANDPICKED_PAIN_WORDS <span class="op">=</span> [<span class="st">"pain"</span>, <span class="st">"tricks"</span>, <span class="st">"cuss"</span>, <span class="st">"rocks"</span>, <span class="st">"feet"</span>, <span class="st">"rash"</span>, <span class="st">"dicks"</span>, <span class="st">"crocodile"</span>, <span class="st">"lenin"</span>, <span class="st">"money"</span>]</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>NEGATIVE_WORDS <span class="op">=</span> HANDPICKED_NEGATIVE_WORDS <span class="op">+</span> HANDPICKED_PAIN_WORDS</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="14">
<details>
<summary>def is_negative(word)</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># handpicked</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>POSITIVE_SENTIMENT_CUTOFF <span class="op">=</span> <span class="fl">0.25</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>NEGATIVE_SENTIMENT_CUTOFF <span class="op">=</span> <span class="fl">0.045</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pos_neg_similarities(word):</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">    return `word`'s cosine-similarity to the average of POSITIVE_WORDS and of NEGATIVE_WORDS</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        pos_similarity <span class="op">=</span> glove_model.n_similarity([word], POSITIVE_WORDS)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        neg_similarity <span class="op">=</span> glove_model.n_similarity([word], NEGATIVE_WORDS)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.0</span>, <span class="fl">0.0</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pos_similarity, neg_similarity</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_negative(pain_word, default<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="co">    True if `pain_word`'s cosine-similarity is closer to NEGATIVE_WORDS than to POSITIVE_WORDS, </span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="co">    or is close enough (with the ratio less than NEGATIVE_SENTIMENT_CUTOFF)</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    pos_similarity, neg_similarity <span class="op">=</span> pos_neg_similarities(pain_word)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pos_similarity <span class="op">==</span> <span class="fl">0.0</span> <span class="kw">or</span> neg_similarity <span class="op">==</span> <span class="fl">0.0</span>:</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> default</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (neg_similarity <span class="op">&gt;</span> pos_similarity) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>           ((pos_similarity <span class="op">-</span> neg_similarity) <span class="op">/</span> pos_similarity) <span class="op">&lt;</span> NEGATIVE_SENTIMENT_CUTOFF</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_positive(champagne_compound_word, default<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="co">    True if `champagne_compound_word`'s cosine-similarity is closer to POSITIVE_WORDS than to NEGATIVE_WORDS, </span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="co">    or is close enough (with the ratio less than POSITIVE_SENTIMENT_CUTOFF)</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    pos_similarity, neg_similarity <span class="op">=</span> pos_neg_similarities(champagne_compound_word)</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pos_similarity <span class="op">==</span> <span class="fl">0.0</span> <span class="kw">or</span> neg_similarity <span class="op">==</span> <span class="fl">0.0</span>:</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> default        </span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (pos_similarity <span class="op">&gt;</span> neg_similarity) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>           ((neg_similarity <span class="op">-</span> pos_similarity) <span class="op">/</span> neg_similarity) <span class="op">&lt;</span> POSITIVE_SENTIMENT_CUTOFF</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_negative(<span class="st">"kissing"</span>)</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_positive(<span class="st">"badness"</span>)</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_negative(<span class="st">"midrash"</span>)</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> is_positive(<span class="st">"rash"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>GLoVe works by translating each word to a series of coordinates, across 200 dimensions. (GLoVe gets those coordinates with machine-learning, deducing that words that occur in similar sentences probably mean similar things.) You can see in this chart that the words we consider positive cluster on the bottom left of the chart, and the ones we consider negative are more towards the top and right.</p>
<div class="cell" data-execution_count="15">
<details>
<summary>plotting positive and negative words on a t-SNE chart</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co"># tsne plot of my handpicked words and a bunch of champagne-words and pain words</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>sham_words <span class="op">=</span> [<span class="st">"meh"</span>, <span class="st">"sham"</span>, <span class="st">"faux"</span>, <span class="st">"bad"</span>, <span class="st">"mid"</span>]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>overrides <span class="op">=</span> {<span class="st">"faux"</span>: <span class="st">"foe"</span>}</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co"># make a list of relevant candidate pain words and champagne compound words to be plotted in the t-SNE chart</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>candidate_champagne_compound_words <span class="op">=</span> []</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>candidate_pain_words <span class="op">=</span> []</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sham_word <span class="kw">in</span> [<span class="st">"meh"</span>, <span class="st">"sham"</span>, <span class="st">"faux"</span>, <span class="st">"bad"</span>, <span class="st">"mid"</span>]:</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    sham_syllable <span class="op">=</span> strict_word_pronunciations[overrides.get(sham_word, sham_word)][<span class="dv">0</span>]</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    nouns_starting_with_sham_word <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> candidate_word: find_candidate_champagne_compound_words(candidate_word, sham_syllable<span class="op">=</span>sham_syllable), </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        strict_noun_pronunciations.items()))</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    candidate_champagne_compound_words <span class="op">+=</span> [n <span class="cf">for</span> n, pron <span class="kw">in</span> nouns_starting_with_sham_word]</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> candidate_champagne_compound_word, _ <span class="kw">in</span> nouns_starting_with_sham_word:</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> candidate_champagne_prons <span class="kw">in</span> <span class="bu">zip</span>(strict_frequent_noun_pronunciations.get(candidate_champagne_compound_word, []), </span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>                reduced_frequent_noun_pronunciations.get(candidate_champagne_compound_word, [])):</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> champagne_pron <span class="kw">in</span> candidate_champagne_prons:</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> sham_syllable <span class="op">!=</span> champagne_pron[:<span class="bu">len</span>(sham_syllable)] <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>                   reduce_phonemes(sham_syllable, vowel_strictness<span class="op">=</span><span class="dv">2</span>) <span class="op">!=</span> champagne_pron[:<span class="bu">len</span>(sham_syllable)]: </span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print("{} doesn't match {}, skipping".format(sham_syllable, champagne_pron)) # just for debug.</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> (pronunciations, syllable_offset), score <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">list</span>(itertools.product(</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>                    [strict_frequent_noun_pronunciations, reduced_frequent_noun_pronunciations], </span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>                                                           ), <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)):</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># gemination is only allowed for consonant-final sham words.</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># "photograph for my real friends, real autograph for my faux friends" should be invalid</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> syllable_offset <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> is_vowel(sham_syllable[<span class="op">-</span><span class="dv">1</span>]): <span class="cf">continue</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> pain_word, pain_prons <span class="kw">in</span> <span class="bu">sorted</span>(pronunciations.items(), key<span class="op">=</span><span class="kw">lambda</span> word_prons: <span class="op">-</span>word_frequencies.get(word[<span class="dv">0</span>], <span class="dv">0</span>)):</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> (champagne_pron[<span class="bu">len</span>(sham_syllable)<span class="op">-</span>syllable_offset:] <span class="kw">in</span> pain_prons):</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>                            candidate_pain_words.append(pain_word)</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>candidate_pain_words <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(candidate_pain_words))</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a><span class="co"># translating the list of words to a Numpy array of the GLoVe vectors for the words</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>PCA_N_COMPONENTS <span class="op">=</span> <span class="dv">21</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>words <span class="op">=</span> POSITIVE_WORDS <span class="op">+</span> NEGATIVE_WORDS <span class="op">+</span> candidate_champagne_compound_words <span class="op">+</span> candidate_pain_words</span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>words <span class="op">=</span> [word <span class="cf">for</span> word <span class="kw">in</span> words <span class="cf">if</span> word <span class="kw">in</span> glove_model]</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>words <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(words)) <span class="co"># remove duplicates</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>vectors <span class="op">=</span> np.array([glove_model[word] <span class="cf">for</span> word <span class="kw">in</span> words] <span class="op">+</span> </span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>                   [np.mean([glove_model[word] <span class="cf">for</span> word <span class="kw">in</span> POSITIVE_WORDS], axis<span class="op">=</span><span class="dv">0</span>)] <span class="op">+</span> </span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>                   [np.mean([glove_model[word] <span class="cf">for</span> word <span class="kw">in</span> NEGATIVE_WORDS], axis<span class="op">=</span><span class="dv">0</span>)])</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>words <span class="op">+=</span> [<span class="st">"mean(POSITIVE_WORDS)"</span>, <span class="st">"mean(NEGATIVE_WORDS)"</span>]</span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a><span class="co"># reducing the dimensionality of those vectors from 200 dimension to 2 with PCA and then t-SNE </span></span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>pca_reduced_vectors <span class="op">=</span> PCA(n_components<span class="op">=</span>PCA_N_COMPONENTS).fit_transform(vectors)</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>np.set_printoptions(suppress<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> TSNE(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">0</span>).fit_transform(pca_reduced_vectors)</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting it</span></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'x'</span>: [x <span class="cf">for</span> x <span class="kw">in</span> Y[:, <span class="dv">0</span>]],</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'y'</span>: [y <span class="cf">for</span> y <span class="kw">in</span> Y[:, <span class="dv">1</span>]],</span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'words'</span>: words})</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"is_positive"</span>] <span class="op">=</span> df.words.<span class="bu">apply</span>(is_positive)</span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"is_negative"</span>] <span class="op">=</span> df.words.<span class="bu">apply</span>(is_negative)</span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"color"</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"handpicked"</span>] <span class="op">=</span> df.words.<span class="bu">apply</span>(<span class="kw">lambda</span> x: x <span class="kw">in</span> HANDPICKED_POSITIVE_WORDS <span class="op">+</span> HANDPICKED_NEGATIVE_WORDS)</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"marker"</span>] <span class="op">=</span> df.handpicked.<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">"o"</span> <span class="cf">if</span> x <span class="cf">else</span> <span class="st">"."</span>)</span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>df.loc[df.is_positive, <span class="st">'color'</span>] <span class="op">=</span> <span class="st">"red"</span></span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a>df.loc[df.is_negative, <span class="st">'color'</span>] <span class="op">=</span> <span class="st">"blue"</span></span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a>df.loc[df.words <span class="op">==</span> <span class="st">"mean(POSITIVE_WORDS)"</span>, <span class="st">'color'</span>] <span class="op">=</span> <span class="st">'red'</span></span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a>df.loc[df.words <span class="op">==</span> <span class="st">"mean(NEGATIVE_WORDS)"</span>, <span class="st">'color'</span>] <span class="op">=</span> <span class="st">'blue'</span></span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a><span class="co">#df.loc[df.is_positive &amp; df.is_negative, 'color'] = "yellow"</span></span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a>df.set_index(<span class="st">'words'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a>word_df <span class="op">=</span> df[<span class="op">~</span>df.index.<span class="bu">str</span>.contains(<span class="st">"mean("</span>, regex<span class="op">=</span><span class="va">False</span>)]</span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a>avg_df <span class="op">=</span> df[df.index.<span class="bu">str</span>.contains(<span class="st">"mean("</span>, regex<span class="op">=</span><span class="va">False</span>)]</span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> polarity <span class="kw">in</span> [<span class="va">True</span>, <span class="va">False</span>]:</span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a>    subdf <span class="op">=</span> word_df[word_df.is_positive <span class="op">==</span> polarity]</span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a>    plt.scatter(subdf.x, subdf.y, c<span class="op">=</span>subdf.color.tolist(), marker<span class="op">=</span><span class="st">'.'</span>, label<span class="op">=</span><span class="st">"positive"</span> <span class="cf">if</span> polarity <span class="cf">else</span> <span class="st">"negative"</span>)</span>
<span id="cb16-81"><a href="#cb16-81" aria-hidden="true" tabindex="-1"></a>plt.scatter(avg_df.x, avg_df.y, c<span class="op">=</span>avg_df.color.tolist(), marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb16-82"><a href="#cb16-82" aria-hidden="true" tabindex="-1"></a>plt.gca().legend()</span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word <span class="kw">in</span> [<span class="st">"mean(POSITIVE_WORDS)"</span>, <span class="st">"mean(NEGATIVE_WORDS)"</span>]:    </span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a>    plt.gca().annotate(word, (df.loc[word].x, df.loc[word].y))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="champagnerealpain_files/figure-html/cell-16-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
</section>
<section id="implementing-our-final-rubric-for-champagne-phrases" class="level2">
<h2 class="anchored" data-anchor-id="implementing-our-final-rubric-for-champagne-phrases">Implementing our final rubric for <code>champagne phrases</code></h2>
<div class="cell" data-execution_count="16">
<details>
<summary>def get_best_pain_word(champagne_prons, sham_syllable):</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_best_pain_word(champagne_prons, sham_syllable, quiet<span class="op">=</span><span class="va">True</span>, filter_by_sentiment<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">    find the most common word that matches the back half of the champagne compound word</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">    if we can't find one, find one that matches the back half of the champagne compound word, </span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">        but repeating the last phoneme of the sham word </span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">        (e.g. chamonix for my real friends, real money for my sham friends)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">        this is "gemination" -- we double up the </span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">    if we still can't find one, try with reduced pronunciations</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># this lets us prefer better vowel matches to worse ones, i.e.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ok: folkrock for my real friends, real crook for my faux friends</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># better: folkrock for my real friends, real croc for my faux friends</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># previously it prefers "crook" because crook is more frequent than croc</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># this also lets us prefer ungeminated matches over geminated ones</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># loop through each pronunciation of the champagne word (often there's just one)</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> champagne_pron <span class="kw">in</span> champagne_prons:</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sham_syllable <span class="op">!=</span> champagne_pron[:<span class="bu">len</span>(sham_syllable)] <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>           reduce_phonemes(sham_syllable, vowel_strictness<span class="op">=</span><span class="dv">2</span>) <span class="op">!=</span> champagne_pron[:<span class="bu">len</span>(sham_syllable)]: </span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print("{} doesn't match {}, skipping".format(sham_syllable, champagne_pron)) # just for debug.</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># loop through the list of strict and reduced pronunciations</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># (where reduced means similar vowels are treated as rhyming, but strict requires an exact match)</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># and the alternatives of a pain word matching (a) the champagne word minus the sham word (e.g. "pain")</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># or (b) the last syllable of the sham word, plus the rest of the champagne word (e.g. "mpain"), called gemination.</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># candidate pain words are considered in four score tiers</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># the score tiers decrements from 3 to 0, where an exact vowel match and non-geminated pain word are worth 3</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># an exact vowel match and a geminated pain word are worth 2</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># a reduced vowel match and non-geminated pain word are worth 1</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># and a reduced vowel match and geminated pain word are worth 0</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># which allows us to filter/sort by scores as part of the final output step</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (pronunciations, syllable_offset), score <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">list</span>(itertools.product(</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>            [strict_frequent_noun_pronunciations, reduced_frequent_noun_pronunciations], </span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>            [<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>                                                   ), <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)):</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>            <span class="co"># gemination is only allowed for consonant-final sham words.</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>            <span class="co"># "photograph for my real friends, real autograph for my faux friends" should be invalid</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> syllable_offset <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> is_vowel(sham_syllable[<span class="op">-</span><span class="dv">1</span>]): <span class="cf">continue</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>            <span class="co"># within our "score tier", higher-frequency words are preferred over lower-frequency words</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>            <span class="co"># and we only consider words that have negative sentiment (if filter_by_sentiment is not false).</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pain_word, pain_prons <span class="kw">in</span> <span class="bu">sorted</span>(pronunciations.items(), key<span class="op">=</span><span class="kw">lambda</span> word_prons: <span class="op">-</span>word_frequencies.get(word[<span class="dv">0</span>], <span class="dv">0</span>)):</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (champagne_pron[<span class="bu">len</span>(sham_syllable)<span class="op">-</span>syllable_offset:] <span class="kw">in</span> pain_prons) <span class="kw">and</span> (is_negative(pain_word) <span class="kw">or</span> <span class="kw">not</span> filter_by_sentiment):</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> pain_word, score</span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>, <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="17">
<details>
<summary>def find_champagne_real_pain_phrases(‘faux’):</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_champagne_real_pain_phrases(sham_word, sham_word_override<span class="op">=</span><span class="va">None</span>, real_word<span class="op">=</span><span class="st">"real"</span>, quiet<span class="op">=</span><span class="va">True</span>, filter_by_sentiment<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sham syllables can be any PoS and need to have the extras added.</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># e.g. "mid" and "faux" are adjectives; "meh" isn't in the CMU pron dictionary.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    sham_syllable <span class="op">=</span> strict_word_pronunciations[sham_word_override <span class="kw">or</span> sham_word][<span class="dv">0</span>]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># find candidate champagne words, which are any noun whose pronunciation begins with the sham word</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    nouns_starting_with_sham_word <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> candidate_word: find_candidate_champagne_compound_words(candidate_word, sham_syllable<span class="op">=</span>sham_syllable), </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        strict_noun_pronunciations.items()</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> quiet:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Here are words (our candidate champagne compound words) that start with </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(sham_syllable))</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> noun, prons <span class="kw">in</span> nouns_starting_with_sham_word:</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>noun<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>prons<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    champagne_pain_pairs <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> candidate_champagne_compound_word, _ <span class="kw">in</span> nouns_starting_with_sham_word:</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># exclude negative candidate champagne words, unless filter_by_sentiment is false.</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> filter_by_sentiment <span class="kw">and</span> <span class="kw">not</span> is_positive(candidate_champagne_compound_word): <span class="cf">continue</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># find the best pain word for each candidate champagne word, if any.</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> candidate_champagne_prons <span class="kw">in</span> <span class="bu">zip</span>(strict_frequent_noun_pronunciations.get(candidate_champagne_compound_word, []), </span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>                reduced_frequent_noun_pronunciations.get(candidate_champagne_compound_word, [])):</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>            best_pain_word, score <span class="op">=</span> get_best_pain_word(candidate_champagne_prons, sham_syllable, filter_by_sentiment<span class="op">=</span>filter_by_sentiment)</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> best_pain_word:</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>                champagne_pain_pairs.add((candidate_champagne_compound_word, best_pain_word, score))    </span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [((<span class="ss">f"</span><span class="sc">{</span>candidate_champagne_compound_word<span class="sc">}</span><span class="ss"> for my </span><span class="sc">{</span>real_word<span class="sc">}</span><span class="ss"> friends, </span><span class="sc">{</span>real_word<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>pain_word<span class="sc">}</span><span class="ss"> for my </span><span class="sc">{</span>sham_word<span class="sc">}</span><span class="ss"> friends"</span>),</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>            {<span class="st">"candidate_champagne_compound_word"</span>: candidate_champagne_compound_word, <span class="st">"real_word"</span>: real_word, <span class="st">"pain_word"</span>: pain_word, <span class="st">"sham_word"</span>: sham_word, <span class="st">"score"</span>: score})</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> candidate_champagne_compound_word, pain_word, score <span class="kw">in</span> <span class="bu">sorted</span>(champagne_pain_pairs, key<span class="op">=</span><span class="kw">lambda</span> x: <span class="op">-</span>x[<span class="dv">2</span>])]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="for-my-faux-sham-mid-meh-and-bad-friends" class="level2">
<h2 class="anchored" data-anchor-id="for-my-faux-sham-mid-meh-and-bad-friends">____ for my faux, sham, mid, meh and bad friends</h2>
<div class="cell" data-execution_count="18">
<details>
<summary>Finding champagne phrases if our sham word is … ‘faux’</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># SHAM_WORD and SHAM_WORD_OVERRIDE were defined in the "A first try" section</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"># SHAM_WORD = faux</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(SHAM_WORD, sham_word_override<span class="op">=</span>SHAM_WORD_OVERRIDE):</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>photos for my real friends, real toes for my faux friends
photon for my real friends, real ton for my faux friends
photo for my real friends, real toe for my faux friends
focus for my real friends, real kis for my faux friends
photons for my real friends, real tons for my faux friends
folkrock for my real friends, real croc for my faux friends
focus for my real friends, real cuss for my faux friends
fomite for my real friends, real might for my faux friends
fomites for my real friends, real mites for my faux friends
foliage for my real friends, real ledge for my faux friends
folklore for my real friends, real clear for my faux friends</code></pre>
</div>
</div>
<div class="cell" data-execution_count="19">
<details>
<summary>Finding champagne phrases if our sham word is … ‘sham’</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"sham"</span>):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>shampoo for my real friends, real poo for my sham friends
shamrocks for my real friends, real rocks for my sham friends
shamrock for my real friends, real rock for my sham friends
champagnes for my real friends, real pains for my sham friends
shamwow for my real friends, real wow for my sham friends
champagne for my real friends, real pain for my sham friends
chamonix for my real friends, real money for my sham friends
chamois for my real friends, real woe for my sham friends</code></pre>
</div>
</div>
<div class="cell" data-execution_count="20">
<details>
<summary>… if our sham word is ‘mid’</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"mid"</span>):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>middling for my real friends, real ling for my mid friends
midnight for my real friends, real knight for my mid friends
midday for my real friends, real day for my mid friends
midline for my real friends, real line for my mid friends
midpoint for my real friends, real point for my mid friends
midrash for my real friends, real rash for my mid friends
middle for my real friends, real ell for my mid friends
medulla for my real friends, real ola for my mid friends</code></pre>
</div>
</div>
<div class="cell" data-execution_count="21">
<details>
<summary>… if our sham word is ‘bad’</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"bad"</span>):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>badges for my real friends, real jaws for my bad friends</code></pre>
</div>
</div>
<div class="cell" data-execution_count="22">
<details>
<summary>… if our sham word is ‘meh’</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"meh"</span>):</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>metrics for my real friends, real tricks for my meh friends
married for my real friends, real reed for my meh friends
medics for my real friends, real dicks for my meh friends
medic for my real friends, real dick for my meh friends
merits for my real friends, real writs for my meh friends
merit for my real friends, real rut for my meh friends
metric for my real friends, real trick for my meh friends
marriage for my real friends, real ridge for my meh friends
merits for my real friends, real ruts for my meh friends
marrow for my real friends, real rho for my meh friends
marriages for my real friends, real ridges for my meh friends
meadows for my real friends, real doze for my meh friends
meadow for my real friends, real doh for my meh friends
method for my real friends, real thud for my meh friends
medals for my real friends, real dolls for my meh friends
message for my real friends, real sedge for my meh friends
medal for my real friends, real dahl for my meh friends
meshes for my real friends, real shows for my meh friends
medico for my real friends, real deco for my meh friends
metals for my real friends, real tolls for my meh friends
melons for my real friends, real loans for my meh friends
metal for my real friends, real tall for my meh friends</code></pre>
</div>
</div>
<div class="cell" data-execution_count="23">
<details>
<summary>… if our sham word is ‘crap’</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"crap"</span>):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>crappie for my real friends, real pee for my crap friends</code></pre>
</div>
</div>
<div class="cell" data-execution_count="24">
<details>
<summary>… if our sham word is ‘barf’</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"barf"</span>):</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>barflies for my real friends, real lies for my barf friends</code></pre>
</div>
</div>
<p>(Crappie is a kind of fish.)</p>
<div class="cell" data-execution_count="25">
<details>
<summary>… if our sham word is ‘ex’</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> champagne_phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"ex"</span>):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>extract for my real friends, real tract for my ex friends
exposition for my real friends, real position for my ex friends
extraction for my real friends, real traction for my ex friends
extracts for my real friends, real tracts for my ex friends
expos for my real friends, real pose for my ex friends
exchequer for my real friends, real checker for my ex friends
exile for my real friends, real isle for my ex friends
exon for my real friends, real son for my ex friends
expert for my real friends, real spurt for my ex friends
experts for my real friends, real spurts for my ex friends
expositions for my real friends, real possessions for my ex friends
expo for my real friends, real paw for my ex friends
exports for my real friends, real parts for my ex friends
export for my real friends, real part for my ex friends
excess for my real friends, real oss for my ex friends
exit for my real friends, real aught for my ex friends
exponent for my real friends, real pennant for my ex friends
extras for my real friends, real straws for my ex friends</code></pre>
</div>
</div>
<div class="cell" data-execution_count="27">
<details>
<summary>regression testing</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># regression testing</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> <span class="bu">any</span>([<span class="st">'photograph'</span> <span class="kw">in</span> phrase <span class="kw">and</span> <span class="st">'autograph'</span> <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"faux"</span>, sham_word_override<span class="op">=</span><span class="st">"foe"</span>)])</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">any</span>([<span class="st">'shamrocks'</span> <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"sham"</span>)])</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">any</span>([<span class="st">'money'</span> <span class="kw">in</span> phrase <span class="kw">and</span> <span class="st">'chamonix'</span> <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"sham"</span>)])</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">any</span>([<span class="st">'midrash'</span> <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"mid"</span>)])</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">any</span>([<span class="st">'folkrock'</span> <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"faux"</span>, sham_word_override<span class="op">=</span><span class="st">"foe"</span>)])</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">any</span>([metadata[<span class="st">"pain_word"</span>] <span class="op">==</span> <span class="st">"croc"</span> <span class="cf">for</span> phrase, metadata <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"faux"</span>, sham_word_override<span class="op">=</span><span class="st">"foe"</span>)])</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">any</span>([<span class="st">'fomites'</span> <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"faux"</span>, sham_word_override<span class="op">=</span><span class="st">"foe"</span>)])</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> NSFW_WORDS_ALLOWED:</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">any</span>([<span class="st">'badges'</span> <span class="kw">in</span> phrase <span class="kw">and</span> unmask_nsfw(<span class="st">'aml6eg=='</span>) <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"bad"</span>)])</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="kw">not</span> <span class="bu">any</span>([<span class="st">'badges'</span> <span class="kw">in</span> phrase <span class="kw">and</span> unmask_nsfw(<span class="st">'aml6eg=='</span>) <span class="kw">in</span> phrase <span class="cf">for</span> phrase, _ <span class="kw">in</span> find_champagne_real_pain_phrases(<span class="st">"bad"</span>)])</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="a-worked-example" class="level2">
<h2 class="anchored" data-anchor-id="a-worked-example">A worked example</h2>
<p>Let’s walk through this step by step.</p>
<p>Chamonix is a province in France. It has two very different pronunciations in the CMU Pronouncing Dictionary. One Americanized pronunciation, <em>tcham-onyx</em> and a French one like <em>sham-oh-knee</em>.</p>
<p>(The Americanized pronunciation – which is incorrect – might be meant for automatic speech recognition systems akin to Siri or Alexa that would have to recognize an incorrect pronunciation, rather than for text-to-speech systems. Or it might be that this particular entry in the CMU Pronouncing Dictionary was generated by an unmotivated undergrad without a background in French.)</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>cmudict.<span class="bu">dict</span>()[<span class="st">"chamonix"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>[['CH', 'AE1', 'M', 'AH0', 'N', 'IH0', 'K', 'S'],
 ['SH', 'AE0', 'M', 'OW0', 'N', 'IY0']]</code></pre>
</div>
</div>
<p>Here’s what the pronunciation looks like with the stresses removed.</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>strict_word_pronunciations[<span class="st">"chamonix"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>[('CH', 'AE', 'M', 'AH', 'N', 'IH', 'K', 'S'),
 ('SH', 'AE', 'M', 'OW', 'N', 'IY')]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>sham_word <span class="op">=</span> <span class="st">"sham"</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>sham_syllable <span class="op">=</span> strict_word_pronunciations[sham_word][<span class="dv">0</span>]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>sham_syllable</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>('SH', 'AE', 'M')</code></pre>
</div>
</div>
<p>See how <code>('SH', 'AE', 'M')</code> is the first half of the second pronunciation, <code>('SH', 'AE', 'M', 'OW', 'N', 'IY')</code></p>
<p>Now, we’re looking to see if there are any <code>pain word</code>s that are pronounced like any of these options for the pronunciation of the back half of <em>chamonix</em>.</p>
<p>First, we’re looking for something that matches <code>('OW', 'N', 'IY')</code> or <code>('M', 'OW', 'N', 'IY')</code> – the back half without any vowel reductions. <code>('OW', 'N', 'IY')</code> would be preferable, since it doesn’t require double-up the <code>M</code> in both the <code>sham word</code> (<em>sham</em>) and the <code>pain word</code> (<em>money</em>, in this case).</p>
<p>Here are those strict pronunciations that we’re looking for.</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> chamonix_pronunciation <span class="kw">in</span> strict_word_pronunciations[<span class="st">"chamonix"</span>]:</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(chamonix_pronunciation[<span class="bu">len</span>(sham_syllable):])</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(chamonix_pronunciation[<span class="bu">len</span>(sham_syllable)<span class="op">-</span><span class="dv">1</span>:])    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>('AH', 'N', 'IH', 'K', 'S')
('M', 'AH', 'N', 'IH', 'K', 'S')
('OW', 'N', 'IY')
('M', 'OW', 'N', 'IY')</code></pre>
</div>
</div>
<p>Or, if we can’t find something that matches the strict, we’d look for something that matches the back half of <em>chamonix</em> with reductions.</p>
<p>Here’s what those reduced pronunciations look like:</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> chamonix_pronunciation <span class="kw">in</span> reduced_frequent_noun_pronunciations[<span class="st">"chamonix"</span>]:</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(chamonix_pronunciation[<span class="bu">len</span>(sham_syllable):])</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(chamonix_pronunciation[<span class="bu">len</span>(sham_syllable)<span class="op">-</span><span class="dv">1</span>:])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>('AH', 'N', 'AH', 'K', 'S')
('M', 'AH', 'N', 'AH', 'K', 'S')
('AH', 'N', 'IY')
('M', 'AH', 'N', 'IY')</code></pre>
</div>
</div>
<p>With those eight acceptable pronunciations in mind, we loop through every noun in the English language, to see if any nouns are pronounced that way. We find three!</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>strict_noun_pronunciations[<span class="st">"money"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>[('M', 'AH', 'N', 'IY')]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>strict_noun_pronunciations[<span class="st">"onyx"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>[('AA', 'N', 'IH', 'K', 'S')]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>strict_noun_pronunciations[<span class="st">"annex"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>[('AE', 'N', 'EH', 'K', 'S'), ('AH', 'N', 'EH', 'K', 'S')]</code></pre>
</div>
</div>
<p>None of those three words match either strict pronunciation of <em>chamonix</em>. So we get no result from <code>get_best_pain_word</code> here.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>get_best_pain_word(strict_noun_pronunciations[<span class="st">"chamonix"</span>], strict_noun_pronunciations[<span class="st">"sham"</span>][<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>(None, None)</code></pre>
</div>
</div>
<p>But they do match the reduced pronunciation of <em>chamonix</em>.</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>get_best_pain_word(reduced_frequent_noun_pronunciations[<span class="st">"chamonix"</span>], strict_noun_pronunciations[<span class="st">"sham"</span>][<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>('money', 3)</code></pre>
</div>
</div>
<p><em>Money</em> is picked becuase it is the more common than either <em>onyx</em> or <em>annex</em>.</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word <span class="kw">in</span> [<span class="st">"money"</span>, <span class="st">"onyx"</span>, <span class="st">"annex"</span>]:</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"frequency of </span><span class="sc">{: &gt;5}</span><span class="st"> is {:,.0f} and it is </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(word, word_frequencies[word], <span class="st">"negative"</span> <span class="cf">if</span> is_negative(word) <span class="cf">else</span> <span class="st">"positive"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>frequency of money is 190,205,072 and it is negative
frequency of  onyx is 2,315,135 and it is negative
frequency of annex is 8,465,905 and it is positive</code></pre>
</div>
</div>
</section>
<section id="future-enhancements" class="level2">
<h2 class="anchored" data-anchor-id="future-enhancements">Future enhancements</h2>
<section id="use-a-for-pain-words-that-are-count-nouns" class="level3">
<h3 class="anchored" data-anchor-id="use-a-for-pain-words-that-are-count-nouns">Use “a” for pain words that are count nouns</h3>
<p>for singular, count nouns, we should add “a” (or “an”) before hand, so it makes a bit more sense.</p>
<ul>
<li><em><strong>a</strong> phoney for my real friends, <strong>a</strong> real knee for my faux friends</em></li>
</ul>
<p>this would be tricky, because we don’t want to do this for mass nouns (like <em>champagne</em>). <a href="https://llds.ling-phil.ox.ac.uk/llds/xmlui/handle/20.500.14106/2469">CUVPlus</a> may be a way to do this, although it regards champagne as a count noun (erroneously, in my view).</p>
<p>Count nouns are those that you refer to individually. A couch, two laptops, many friends. Mass nouns are referred to regardless of their quantity: coffee, champagne, sand. Some nouns can be both, like <em>squirrel</em>. (<em>I like squirrels</em> means something different from <em>I like squirrel</em>, which implies that you like eating squirrel meat.)</p>
</section>
<section id="metrics-for-my-real-friends" class="level3">
<h3 class="anchored" data-anchor-id="metrics-for-my-real-friends">Metrics for my real friends</h3>
<p>compile all the examples here and get some humans to rate them on how funny they are, and see if we can’t figure out some more rules to filter out the crappy ones and generate more funny ones.</p>
</section>
<section id="better-phonology" class="level3">
<h3 class="anchored" data-anchor-id="better-phonology">Better phonology</h3>
<p>The vowel reduction logic above is pretty rough. My linguistics education is rusty enough that I can’t write a rule to exclude false-positive matches like <em>medulla for my real friends, real allah for my mid friends</em>.</p>
<p>Additionally, diphthongs are often close enough to single vowels to count as a rhyme. You could imagine <em>Champlain for my real friends, real playin’ for my sham friends</em> working, but the code as of now wouldn’t be able to equate <em>plain</em> and <em>playin’</em>.</p>
<p>The matching logic could also allow voiced and unvoiced consonants (that share a place of articulation) to match, which would allow sentences like <em>extremes for my real friends, real dreams for my ex friends</em>.</p>
</section>
<section id="exclude-true-compound-words" class="level3">
<h3 class="anchored" data-anchor-id="exclude-true-compound-words">Exclude true compound words</h3>
<p>This methodology accepts <code>champagne phrases</code> like <em>midwives for my real friends, real wives for my mid friends</em>. This isn’t a very satisfying phrase, since <em>midwives</em> is transparently a compound of <em>mid</em> + <em>wives</em>. Less transparent compounds like <em>champagne</em> should be preferred.</p>
</section>
<section id="improve-positivenegative-classification" class="level3">
<h3 class="anchored" data-anchor-id="improve-positivenegative-classification">Improve positive/negative classification</h3>
<p>It’d be great to find a better way to classify pain words as negative or not. This is one place where GPT4 might do a good job! A traditional classifier based on the VADER wordlist and GLoVE vectors might also do a good enough job of capturing our very specific sense of positivity/negativity, too.</p>
<section id="what-about-vader-or-afinn" class="level4">
<h4 class="anchored" data-anchor-id="what-about-vader-or-afinn">What about VADER (or AFINN)?</h4>
<p>VADER is a time-tested dictionary-based sentiment analysis methodology – that is, it’s a big list of hand-picked words rated by how positive or negative they are. The code below is a first stab at using VADER to filter out pain words that aren’t classified as negative. But the VADER lexicon list is relatively small, and many negative words words – like <em>mites</em> – aren’t on it, so many good phrases get incorrectly excluded. (Another sentiment wordlist, AFINN, only contains pain words already present in VADER.)</p>
<p>We’d only get these five results (which are pretty good, but fewer than we’d want) with the VADER methodology.</p>
<div class="cell" data-execution_count="39">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nltk.sentiment.vader <span class="im">import</span> SentimentIntensityAnalyzer</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>nltk_download(<span class="st">'vader_lexicon'</span>, quiet<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> SentimentIntensityAnalyzer()</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>overrides <span class="op">=</span> {<span class="st">"faux"</span>: <span class="st">"foe"</span>}</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sham_word <span class="kw">in</span> [<span class="st">"meh"</span>, <span class="st">"sham"</span>, <span class="st">"faux"</span>, <span class="st">"bad"</span>, <span class="st">"mid"</span>]:</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> champagne_phrase, metadata <span class="kw">in</span> find_champagne_real_pain_phrases(sham_word, sham_word_override<span class="op">=</span>overrides.get(sham_word)):</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s.lexicon.get(metadata[<span class="st">"pain_word"</span>], <span class="dv">0</span>) <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(champagne_phrase)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>metrics for my real friends, real tricks for my meh friends
medic for my real friends, real dick for my meh friends
metric for my real friends, real trick for my meh friends
champagnes for my real friends, real pains for my sham friends
champagne for my real friends, real pain for my sham friends
chamois for my real friends, real woe for my sham friends
midrash for my real friends, real rash for my mid friends</code></pre>
</div>
</div>
</section>
</section>
<section id="what-pain-words-are-excluded-by-the-existing-positivenegative-methodology" class="level3">
<h3 class="anchored" data-anchor-id="what-pain-words-are-excluded-by-the-existing-positivenegative-methodology">What pain words are excluded by the existing positive/negative methodology?</h3>
<div class="cell" data-execution_count="40">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sham_word <span class="kw">in</span> [<span class="st">"faux"</span>, <span class="st">"sham"</span>, <span class="st">"mid"</span>, <span class="st">"meh"</span>, <span class="st">"bad"</span>]:</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> champagne_phrase, metadata <span class="kw">in</span> find_champagne_real_pain_phrases(sham_word, sham_word_override<span class="op">=</span>overrides.get(sham_word), filter_by_sentiment<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_negative(metadata[<span class="st">"pain_word"</span>], default<span class="op">=</span><span class="va">False</span>) <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>           is_positive(metadata[<span class="st">"candidate_champagne_compound_word"</span>], default<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(champagne_phrase)</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>photons for my real friends, real tonnes for my faux friends
focuses for my real friends, real kisses for my faux friends
focusing for my real friends, real kissing for my faux friends
focusing for my real friends, real kissing for my faux friends
focuses for my real friends, real kisses for my faux friends

shamrock for my real friends, real roc for my sham friends

midwife for my real friends, real wife for my mid friends
midsummer for my real friends, real summer for my mid friends
midwives for my real friends, real wives for my mid friends

mesquite for my real friends, real skeet for my meh friends
menus for my real friends, real news for my meh friends
married for my real friends, real read for my meh friends
melons for my real friends, real lawns for my meh friends
melon for my real friends, real lawn for my meh friends

</code></pre>
</div>
</div>
<p>In particular, I like</p>
<ul>
<li><em>chamonix for my real friends, real money for my sham friends</em></li>
<li><em>menus for my real friends, real news for my meh friends</em></li>
</ul>
<p>but they don’t quite fit the rubric (since neither <em>money</em> nor <em>news</em> is really negative.)</p>
<p>Thoughts? Improvements? Suggestions on more <code>sham words</code> I should plug in? Please send me an <a href="https://jeremybmerrill.com/contact/">email</a>, message me on <a href="https://journa.host/@jeremybmerrill">Mastodon</a> or <a href="https://bsky.app/profile/jeremybmerrill.com">Bluesky</a> or open a <a href="https://github.com/jeremybmerrill/champagne_real_pain">Github issue</a>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>